\documentclass[a4paper,10pt,twoside]{article}
% \pdfoutput=1 

\usepackage[bookmarks=true,colorlinks=true]{hyperref}

\usepackage{bookmark}
\bookmarksetup{
 numbered, 
 open,
}


\usepackage{todonotes}

\usepackage{amssymb,amsmath}       % Equations
\usepackage{array}
\usepackage{bm}                    % Bold math symbols
\usepackage{epsfig}
\usepackage{float}
\usepackage{graphicx,color,psfrag} % Graphics, Figures
\usepackage[export]{adjustbox}
\usepackage{subcaption}
\usepackage{tikz}

\usepackage{multirow}              % For Tables
\usepackage{tabularx}              % Tables
\usepackage{wrapfig}
\usepackage[algoruled]{algorithm2e}
\SetStartEndCondition{ }{}{}%
\SetKwProg{Fn}{def}{\string:}{}
\SetKwFunction{Range}{range}%%
\SetKw{KwTo}{in}\SetKwFor{For}{for}{\string:}{}%
\SetKwIF{If}{ElseIf}{Else}{if}{:}{elif}{else:}{}%
\SetKwFor{While}{while}{:}{}%
% \renewcommand{\forcond}{$i$ \KwTo\Range{$n$}}
\AlgoDontDisplayBlockMarkers\SetAlgoNoEnd\SetAlgoNoLine%


%% enumitem 
% \labelindent is defined in both IEEEtrans and
% enumitem. \let\labelindent\relax kind-of disables \labelindent
% defined in IEEEtrans, hence avoiding the name clash.
\let\labelindent\relax
\usepackage[inline]{enumitem}

% variables
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}
% acronyms
\newcommand{\ie}{{\textit{i.e.}}}
\newcommand{\etal}{\textit{et~al.}}

% theorem environment
\usepackage{amsthm}
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}
% \newtheorem{exercise}{Exercise}[section]
\newtheorem{example}[theorem]{Example}

% Redefine exercise formating 
% \theoremstyle{plain}
\newtheorem{exercise}{Exercise}


% figures path
\graphicspath{{figures/}}

% \overrideIEEEmargins
% set margins
\setlength{\floatsep}{2pt plus 1pt minus 1pt}
\setlength{\textfloatsep}{5pt plus 1pt minus 2pt}

%% TITLE
\title{Homework 3}
%% AUTHOR
\author{Pham Tien Hung, Zhang Xu}

%% DATE
\date{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\maketitle
\listoftodos
\begin{exercise}[Sort $k$ sorted lists.]\

Idea is to use a Priority Queue (min heap) to keep the smallest
elements $k$ lists. Then at each iteration, we remove the smallest
element from the Queue, pop that element from its list and add in
the next smallest element in that list into the queue.
\begin{algorithm}[h]
	\caption{Sort $k$ sorted lists ($L[1...k][:]$)}
	$Queue$ = Make-queue()\;
	Let $X$ be an empty list\;
	\For{$i$ in $[1,...,k]$}{
		Add($i$, $L[i][1]$)\;
	}
	\For{$i$ in $[1,...,n]$}{
		$j$ = Extract-min($Queue$) \tcp*{pop the $j$-th list}
		$x$ = pop($L[j][1]$) \tcp*{Remove the first element}
		Add $x$ to $X$\;
		Add($j$, $L[j][1]$, $Queue$) \tcp*{add the $j$-th list 1st element back}
	}
	\Return $X$\;
\end{algorithm}

\textbf{Complexity}

This algorithm requires $O(n)$ Extract-min and $O(n)$ Add. Each Add 
operation has complexity $O(\log k)$. Thus the total complexity is
$O(n \log k)$


\end{exercise}

\begin{exercise}[Computation of the Fibonacci number]
We shall make use of the following relation
\begin{equation}
	\begin{pmatrix}
		1 & 1\\ 1 & 0
	\end{pmatrix}
	\begin{pmatrix}F(n-1)\\F(n-2)\end{pmatrix}
	= \begin{pmatrix}F(n)\\F(n-1)\end{pmatrix}
\end{equation}
Clearly, from this we obtain
\begin{equation}
	A^n [F(0), F(1)]^T = [F(n), F(n-1)]^T
\end{equation}
where $A = \begin{pmatrix}1 & 1\\ 1 & 0\end{pmatrix}$.

\begin{algorithm}[H]
	\caption{Fib($n$)}
	Let $A$ be the matrix $\begin{pmatrix}1 & 1\\ 1 & 0\end{pmatrix}$\;
	M = exponential-by-squaring($A$, $n$)\;
	$F(n)$ = multiply($M,[1, 1]$)[0]\;
	\Return $F(n)$
\end{algorithm}


\textbf{Complexity}

Computing $A^n$ takes $O(\log n)$ matrix multiplication (of constant
size), thus the time complexity is $O(\log n)$.
\end{exercise}
\begin{exercise}[Computing maximum sum of contiguous subarray]\

\textbf{a)} Denoting $S(i, j)$ as the sum of the array starting
from the $i$-th element to the $j$-th element, that is
\[
	S(i, j) = \begin{cases}
		0 \text{ if $i < j$}\\
		\sum_{k=i}^j L[k] \text{ otherwise}\\
	\end{cases}
\]
\begin{algorithm}[H]
	\caption{Naive summation}
	Let $(1, 1)$ be the selected elements\;
	Let sum = $-\infty$ \;
	Initialize S as a n-by-n zero matrix\;
	\For{$i$ in $[1,...,n]$}{
		\For{$j$ in $[1,...,n]$}{
			\If{j $>$ i}{
			$S[i, j] = S[i, j - 1] + L[j]$\;
			\If{$S[i, j] > sum$}{
			select i, j\;
			sum = S[i, j]
			}
			}
		}
	}
	\Return sum
\end{algorithm}
\textbf{b)} Defining $S_{left}[i]$
as the sum of all element on the left of $j$ including $j$
\[
	S_{left}[i] = \sum_{j=1}^i L[j].
\]
\end{exercise}

Next, we find two elements $e_{min}$ and $e_{max}$ such that
\[
\begin{aligned}
	e_{min} = \argmin_i S_{left}[i],\\
	e_{max} = \argmax_i S_{left}[i].\\
\end{aligned}
\]
Now, the maximum continguous subarray is given by $[e_{min}+1,...,e_{max}]$.

\begin{algorithm}[H]
\caption{Find maximum contiguous array(L)}
Initialize zero array with length $n$ $S_{left}$\;
Let $S_{left}[1]$ = $L[1]$\;
\For {$i$ in $[2,...n]$}{
	$S_{left}[i] = S_{left}[i-1] + L[i]$
}
Let $e_{min}$ = $e_{max}$ = 1\;
\For {$i$ in $1,...n$}{
	\If{$S_{left}[i] \geq S_{left}[e_max]$}{
	$e_{max} = i$\;
	}
	\If{$S_{left}[i] \leq S_{left}[e_min]$}{
	$e_{min} = i$\;
	}
}
\Return $[e_{min} +1, ..., e_{max}]$
\end{algorithm}

\textbf{Complexity}

Time complexities of all operations are $\Theta(n)$.

\begin{proof}
To show that our algorithm produces correct result, we start from the
problem statement
\[
	\begin{aligned}
	&\max_{i, j} \sum_{k=i}^j L[k] \\
	=&\max_{i, j} \left( \sum_{k=1}^j L[k] - \sum_{k=1}^{i-1} L[k] \right)\\
	=&\max_{j} \sum_{k=1}^j L[k] - \min_{i}\sum_{k=1}^{i-1} L[k] 
	\end{aligned}
\]
Our algorithm produces the corresponding $\argmax_j\sum_{k=1}^j L[k]$ 
and $\argmin_i\sum_{k=1}^{i-1} L[k]$.
\end{proof}
\begin{exercise}[Arbitrage]\

Compute the logarithm of the exhcange matrix $R[,]$, then construct
a graph based on this matrix. Find negative cycle on this graph 
using Floyd-Warshall.

\todo{Check problem statement for the actual question ten complete the
proof.}

\begin{algorithm}[H]
\caption{Check for negative Arbitrage($R[:, :]$)}
\label{algo:negative-arbitrage}
	Let $Adj[:, :]$ be the logarithm of the matrix $R[:,:]$\;
	Construct graph $G(Adj)$\;
	have-negative-cycle = Floyd-Warshall($G$)\;
	\Return have-negative-cycle
\end{algorithm}

\begin{proof}
We relies on the relation
\[
\begin{aligned}
&\log (R[i_1, i_2]R[i_2, i_3]...R[i_k, i_1])\\
=&\log R[i_1, i_2] + \log R[i_2, i_3] + ... + \log R[i_k, i_1]
\end{aligned}
\]
\end{proof}
\end{exercise}	
\begin{exercise}
\todo{Do exercise 5.}
\end{exercise}
\end{document}






















